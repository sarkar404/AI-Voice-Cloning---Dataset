# 🧠 How to Use Processed Data for ML/DL Projects

> **Document Purpose:**  
> This guide explains how to use the pre-processed outputs generated by the RBP-DSP pipeline for **machine learning (ML)** and **deep learning (DL)** tasks.  
> It covers dataset structure, metadata usage, reorganization steps, and practical examples to start model development.

---

## 🚀 1. Overview

The **RBP-DSP** pipeline performs advanced digital signal processing on raw speech data.  
It includes:
- Audio extraction and normalization  
- Noise/dehum/dereverb cleaning  
- Voice activity segmentation (VAD)  
- Feature extraction (MFCC, Mel, LPC, Prosody, Phonetics)  
- TextGrid annotation scaffolds  
- Verification and KPI reports  

Once the pipeline finishes, you have a **scientifically curated dataset** ideal for ML/DL projects in speech, linguistics, and phonetics.

---

## 🧩 2. Understanding the Directory Structure

After a full pipeline run, your workspace will look like this:

processed_data/
├── 1_acquisition_preprocessing/
│ └── _resampled.wav
├── 2_signal_separation_chain/
│ ├── dehum_corrected/
│ ├── dereverbed/
│ ├── denoised/
│ ├── normalized/
│ └── vad_segments/.wav ← speech-active chunks
├── 3_phonetic_linguistic_features/
│ ├── acoustic/.npz ← MFCC, Mel, ΔΔ, etc.
│ ├── prosodic/.csv ← f₀, energy, rhythm, duration
│ ├── phonetic/.csv ← jitter, shimmer, formant stats
│ └── linguistic/.npy ← LPC, PNCC, etc.
├── 4_annotation_alignment/
│ └── textgrids/.TextGrid ← time-aligned scaffolds
└── 5_validation_verification/
├── reports/scientific_evaluation.csv
├── figures/.png
└── evaluation_summary.txt

metadata/
├── sources.csv ← original file metadata
├── segments.csv ← all speech segments (timestamps)
└── processing_log.jsonl ← stepwise pipeline logs




---

## 🧱 3. From Processed Data to ML Dataset

The DSP pipeline produces **rich but hierarchical outputs**.  
To simplify ML use, we generate a flattened dataset using:




python scripts/prepare_dataset.py


This script gathers all valid audio, features, and metadata and creates:



dataset_ready/
├── audio/
│ ├── segment_0001.wav
│ ├── segment_0002.wav
│ └── ...
├── features/
│ ├── segment_0001.npz
│ ├── segment_0002.npz
│ └── ...
├── labels.csv
├── dataset_summary.txt
├── dataset_statistics.png
├── feature_scaler_mean.npy
└── feature_scaler_std.npy




Now, **dataset_ready/** is fully standardized and portable.  
You can directly load it in Python, PyTorch, TensorFlow, or Scikit-learn workflows.

---

## 🧬 4. Typical Use Cases

| Application Type | Input Features | Target or Label | Example Goal |
|------------------:|----------------|-----------------|---------------|
| **Speaker Classification** | MFCC, LPC, F₀ | Speaker ID | Identify who is speaking |
| **Emotion Recognition** | Prosody + MFCC | Emotion Label | Detect emotional tone |
| **Speech Quality Assessment** | Acoustic + Phonetic | PESQ, STOI | Predict perceived audio quality |
| **Accent/Dialect Analysis** | LPC + Formants | Region/Accent | Linguistic classification |
| **Phonetic Feature Modeling** | Jitter, Shimmer, F₀ | Phoneme attributes | Compare healthy vs disordered speech |
| **Automatic Speech Recognition (ASR)** | Audio + TextGrid | Word/phoneme alignment | Train end-to-end ASR models |

---

## 🧰 5. How to Load and Use the Dataset in Python

### Example: Load and Explore Features

```python
import numpy as np
import pandas as pd

# Load labels
labels = pd.read_csv("dataset_ready/labels.csv")
print(labels.head())

# Load one sample
sample_id = labels.iloc[0]["segment_id"]
data = np.load(f"dataset_ready/features/{sample_id}.npz")

print("Available feature arrays:", data.files)
mfcc = data["mfcc"]
print("MFCC shape:", mfcc.shape)
```


Example: Train a Simple ML Model (Speech Quality Prediction)


```python
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score, mean_squared_error
import numpy as np
import pandas as pd
from glob import glob

# Load mean MFCCs as feature vectors
files = sorted(glob("dataset_ready/features/*.npz"))
X = [np.load(f)["mfcc"].mean(axis=1) for f in files]
X = np.stack(X)

# Load target quality metric (e.g., PESQ)
df_eval = pd.read_csv("processed_data/5_validation_verification/reports/scientific_evaluation.csv")
y = df_eval["PESQ"].values[:len(X)]

# Train/test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Model
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

print(f"R² = {r2_score(y_test, y_pred):.3f}, RMSE = {mean_squared_error(y_test, y_pred, squared=False):.3f}")
```


Example: Use with PyTorch for Deep Learning
```python
import torch
from torch.utils.data import Dataset
import numpy as np
import soundfile as sf
import pandas as pd
from pathlib import Path

class SpeechDataset(Dataset):
    def __init__(self, root="dataset_ready"):
        self.df = pd.read_csv(Path(root) / "labels.csv")
        self.audio_dir = Path(root) / "audio"
        self.feat_dir = Path(root) / "features"

    def __len__(self):
        return len(self.df)

    def __getitem__(self, idx):
        row = self.df.iloc[idx]
        seg_id = row["segment_id"]
        feat = np.load(self.feat_dir / f"{seg_id}.npz")["mfcc"]
        feat_tensor = torch.tensor(feat, dtype=torch.float32)
        return feat_tensor, seg_id

dataset = SpeechDataset()
print(f"Loaded {len(dataset)} samples.")
```

This structure can directly feed models such as:

CNNs for spectral classification

LSTMs/Transformers for temporal features

Multimodal models combining acoustic and linguistic data


📈 6. Dataset Statistics and Integrity

Each dataset build also generates:

dataset_summary.txt — high-level stats (count, durations, total hours)

dataset_statistics.png — histogram of segment durations

feature_scaler_mean.npy, feature_scaler_std.npy — global normalization vectors

Use these for dataset validation before training:


```python
import numpy as np

mean = np.load("dataset_ready/feature_scaler_mean.npy")
std = np.load("dataset_ready/feature_scaler_std.npy")
print("Feature normalization mean/std shapes:", mean.shape, std.shape)
```


🔬 7. Academic / Research Use

This dataset is research-ready for:

Comparative DSP evaluations

Supervised or unsupervised ML experiments

Reproducibility studies in linguistics or signal science

Voice quality and speech pathology research

Phonetic, prosodic, or sociolinguistic analysis

When publishing, cite the RBP-DSP pipeline as the data preprocessing system
and reference its configuration (cfg/core_config.yml) for reproducibility.



💾 8. Packaging for External Teams

Once the dataset is ready, you can compress and share it:

```
python scripts/prepare_dataset.py
tar -czvf dataset_ready_v1.tar.gz dataset_ready/
sha256sum dataset_ready_v1.tar.gz > dataset_ready_v1_sha256.txt
```


The receiving team can simply unpack it and begin model training.


🧭 9. Summary

✅ You now have a complete, clean, and scientifically validated speech dataset.
It can be used for:

Training deep neural networks

Benchmarking DSP methods

Linguistic or speech analysis

Student and PhD-level experiments

By following this workflow, your data pipeline remains:

Traceable (metadata and logs)

Reproducible (config-driven)

Modular (each stage can evolve independently)

Portable (dataset_ready/ is self-contained)

Authored by:
RBP-DSP Core Engineering Team
© 2025 | Research-Grade DSP + ML Workflow